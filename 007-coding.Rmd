# Coding Principles

This class is about two kinds of fundamental principles of coding. The first is fundamental methods of making code do what you want - if statement, loops, functions. The second is fundamental principles of good code. Although we are using R both kinds of principles hold when you write in other computer languages.

## Fundamental methods

1. [if statements](#if)
2. [loops](#loops)
3. [functions](#functions)



### If statements

So far we have written simple scripts that do things in order, top to bottom

```{r}
a <- 1 # define a variable
a <- a + 1 #add 1
print(a) # output the result
```

The first block above is the code, the second block (the lines which start with `##`) is the output.

Changing which statements are run is called "flow control". An "If statement" is a fundamental way of doing this. It allows us to specify one set statements to run if a certain conditions is met. For example

```{r}
a <- 1 # define a variable
a <- a + 1 #add 1
if(a>4) # this is the condition which has to be met, the 'test expression'
{print(a)} # this statement runs if the test expression is true
```

Notice there is no output. Copy the code to your own computer and run it. Now change the first line to `a <- 9` and run it again.

An If statement defines a branch in the flow of a script. The default can be nothing happening, but sometimes you want to define two alternatives. You can do this with an "If...else...statement"

```{r}
a <- 1 # define a variable
a <- a + 1 #add 1
if(a>4){ # this is the condition which has to be met, the 'test expression'
  print(paste(a," is more than 4")) # this statement runs if the test expression is true
} else {
  {print(paste(a," is equal or less than 4"))} # this statement runs if the test expression is false
}
```

You can actually have as many branches as you like, defining a series of test_expression, like this

```{r}
type_of_thing='' 
print("Is four a lot?")
if (type_of_thing=='Murders'){
  print("yes")
} else if (type_of_thing=='Dollars'){
  print("no")
} else {
  print("Depends on the context")
}
```



### Loops{#loops}

Loops are another way of flow control, but instead of branching they just repeat

```{r}
for (i in 1:5){
  print(i)
}
```

This is more usesful than it might seem at first

```{r}
years <- 10 #how many years since you started saving
savings <-100 #how much you start with
interest <- 1.05 #rate of interest, ie 5% interest
#Calculate using a loop
for (years in 1:years){
  savings<-savings*interest
}
print(paste("After", years, "years you will have Â£", round(savings,2))) #save more, kids
```
Lots of people advice against using loops because they are can be slow and it isn't always obvious what they are doing. Alternatives often exist, like vectorisation.

```{r}
years <- 20 #how many years since you started saving
savings <-100 #how much you start with
interest <- 1.05 #rate of interest, ie 5% interest
#Calculate using a vector
total_at_each_year=savings*interest**(1:years)
plot(total_at_each_year,xlab="years") #bonus! We store all the intervening values
```

The problem is, loops are the natural way to think about some problems. Often I first write my code with loops then, when I know what I really want to do I try and work out a way to do it with vectorisation. 




### Functions {#functions}

We need to add one *argument*, the p-value you want to report. The names you choose for the arguments are private to that argument, so it is not a problem if they conflict with other variables in your script. You put the arguments in the parentheses after `function` in the order you want them to default (just like the built-in functions you've used before). 

```{r}
report_p <- function(p) {
}
```

## Fundamental principles of good code

### Comment

Your most important collaborator is you from six months ago, and they don't answer email.


### Functionalise

Shorter code

A shortcut when writing code

A shortcut when reading code



### Avoid hard coded values

Transparency

Flexibility


### Ask for help

Writing a complete example

Your code is good enough to share